{"ast":null,"code":"/*!\r\n * hoverIntent v1.8.1 // 2014.08.11 // jQuery v1.9.1+\r\n * http://briancherne.github.io/jquery-hoverIntent/\r\n *\r\n * You may use hoverIntent under the terms of the MIT license. Basically that\r\n * means you are free to use hoverIntent as long as this header is left intact.\r\n * Copyright 2007, 2014 Brian Cherne\r\n */\n\n/* hoverIntent is similar to jQuery's built-in \"hover\" method except that\r\n * instead of firing the handlerIn function immediately, hoverIntent checks\r\n * to see if the user's mouse has slowed down (beneath the sensitivity\r\n * threshold) before firing the event. The handlerOut function is only\r\n * called after a matching handlerIn.\r\n *\r\n * // basic usage ... just like .hover()\r\n * .hoverIntent( handlerIn, handlerOut )\r\n * .hoverIntent( handlerInOut )\r\n *\r\n * // basic usage ... with event delegation!\r\n * .hoverIntent( handlerIn, handlerOut, selector )\r\n * .hoverIntent( handlerInOut, selector )\r\n *\r\n * // using a basic configuration object\r\n * .hoverIntent( config )\r\n *\r\n * @param  handlerIn   function OR configuration object\r\n * @param  handlerOut  function OR selector for delegation OR undefined\r\n * @param  selector    selector OR undefined\r\n * @author Brian Cherne <brian(at)cherne(dot)net>\r\n */\n;\n\n(function (factory) {\n  'use strict';\n\n  if (typeof define === 'function' && define.amd) {\n    define(['jquery'], factory);\n  } else if (jQuery && !jQuery.fn.hoverIntent) {\n    factory(jQuery);\n  }\n})(function ($) {\n  'use strict'; // default configuration values\n\n  var _cfg = {\n    interval: 100,\n    sensitivity: 6,\n    timeout: 0\n  }; // counter used to generate an ID for each instance\n\n  var INSTANCE_COUNT = 0; // current X and Y position of mouse, updated during mousemove tracking (shared across instances)\n\n  var cX, cY; // saves the current pointer position coordinates based on the given mousemove event\n\n  var track = function (ev) {\n    cX = ev.pageX;\n    cY = ev.pageY;\n  }; // compares current and previous mouse positions\n\n\n  var compare = function (ev, $el, s, cfg) {\n    // compare mouse positions to see if pointer has slowed enough to trigger `over` function\n    if (Math.sqrt((s.pX - cX) * (s.pX - cX) + (s.pY - cY) * (s.pY - cY)) < cfg.sensitivity) {\n      $el.off(s.event, track);\n      delete s.timeoutId; // set hoverIntent state as active for this element (permits `out` handler to trigger)\n\n      s.isActive = true; // overwrite old mouseenter event coordinates with most recent pointer position\n\n      ev.pageX = cX;\n      ev.pageY = cY; // clear coordinate data from state object\n\n      delete s.pX;\n      delete s.pY;\n      return cfg.over.apply($el[0], [ev]);\n    } else {\n      // set previous coordinates for next comparison\n      s.pX = cX;\n      s.pY = cY; // use self-calling timeout, guarantees intervals are spaced out properly (avoids JavaScript timer bugs)\n\n      s.timeoutId = setTimeout(function () {\n        compare(ev, $el, s, cfg);\n      }, cfg.interval);\n    }\n  }; // triggers given `out` function at configured `timeout` after a mouseleave and clears state\n\n\n  var delay = function (ev, $el, s, out) {\n    delete $el.data('hoverIntent')[s.id];\n    return out.apply($el[0], [ev]);\n  };\n\n  $.fn.hoverIntent = function (handlerIn, handlerOut, selector) {\n    // instance ID, used as a key to store and retrieve state information on an element\n    var instanceId = INSTANCE_COUNT++; // extend the default configuration and parse parameters\n\n    var cfg = $.extend({}, _cfg);\n\n    if ($.isPlainObject(handlerIn)) {\n      cfg = $.extend(cfg, handlerIn);\n\n      if (!$.isFunction(cfg.out)) {\n        cfg.out = cfg.over;\n      }\n    } else if ($.isFunction(handlerOut)) {\n      cfg = $.extend(cfg, {\n        over: handlerIn,\n        out: handlerOut,\n        selector: selector\n      });\n    } else {\n      cfg = $.extend(cfg, {\n        over: handlerIn,\n        out: handlerIn,\n        selector: handlerOut\n      });\n    } // A private function for handling mouse 'hovering'\n\n\n    var handleHover = function (e) {\n      // cloned event to pass to handlers (copy required for event object to be passed in IE)\n      var ev = $.extend({}, e); // the current target of the mouse event, wrapped in a jQuery object\n\n      var $el = $(this); // read hoverIntent data from element (or initialize if not present)\n\n      var hoverIntentData = $el.data('hoverIntent');\n\n      if (!hoverIntentData) {\n        $el.data('hoverIntent', hoverIntentData = {});\n      } // read per-instance state from element (or initialize if not present)\n\n\n      var state = hoverIntentData[instanceId];\n\n      if (!state) {\n        hoverIntentData[instanceId] = state = {\n          id: instanceId\n        };\n      } // state properties:\n      // id = instance ID, used to clean up data\n      // timeoutId = timeout ID, reused for tracking mouse position and delaying \"out\" handler\n      // isActive = plugin state, true after `over` is called just until `out` is called\n      // pX, pY = previously-measured pointer coordinates, updated at each polling interval\n      // event = string representing the namespaced event used for mouse tracking\n      // clear any existing timeout\n\n\n      if (state.timeoutId) {\n        state.timeoutId = clearTimeout(state.timeoutId);\n      } // namespaced event used to register and unregister mousemove tracking\n\n\n      var mousemove = state.event = 'mousemove.hoverIntent.hoverIntent' + instanceId; // handle the event, based on its type\n\n      if (e.type === 'mouseenter') {\n        // do nothing if already active\n        if (state.isActive) {\n          return;\n        } // set \"previous\" X and Y position based on initial entry point\n\n\n        state.pX = ev.pageX;\n        state.pY = ev.pageY; // update \"current\" X and Y position based on mousemove\n\n        $el.off(mousemove, track).on(mousemove, track); // start polling interval (self-calling timeout) to compare mouse coordinates over time\n\n        state.timeoutId = setTimeout(function () {\n          compare(ev, $el, state, cfg);\n        }, cfg.interval);\n      } else {\n        // \"mouseleave\"\n        // do nothing if not already active\n        if (!state.isActive) {\n          return;\n        } // unbind expensive mousemove event\n\n\n        $el.off(mousemove, track); // if hoverIntent state is true, then call the mouseOut function after the specified delay\n\n        state.timeoutId = setTimeout(function () {\n          delay(ev, $el, state, cfg.out);\n        }, cfg.timeout);\n      }\n    }; // listen for mouseenter and mouseleave\n\n\n    return this.on({\n      'mouseenter.hoverIntent': handleHover,\n      'mouseleave.hoverIntent': handleHover\n    }, cfg.selector);\n  };\n});","map":{"version":3,"sources":["C:\\Users\\Pratibha Hotwani\\Desktop\\Master\\User-Interface\\src\\components\\Home\\lib\\superfish\\hoverIntent.js"],"names":["factory","define","amd","jQuery","fn","hoverIntent","$","_cfg","interval","sensitivity","timeout","INSTANCE_COUNT","cX","cY","track","ev","pageX","pageY","compare","$el","s","cfg","Math","sqrt","pX","pY","off","event","timeoutId","isActive","over","apply","setTimeout","delay","out","data","id","handlerIn","handlerOut","selector","instanceId","extend","isPlainObject","isFunction","handleHover","e","hoverIntentData","state","clearTimeout","mousemove","type","on"],"mappings":"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","sourcesContent":["/*!\r\n * hoverIntent v1.8.1 // 2014.08.11 // jQuery v1.9.1+\r\n * http://briancherne.github.io/jquery-hoverIntent/\r\n *\r\n * You may use hoverIntent under the terms of the MIT license. Basically that\r\n * means you are free to use hoverIntent as long as this header is left intact.\r\n * Copyright 2007, 2014 Brian Cherne\r\n */\r\n\r\n/* hoverIntent is similar to jQuery's built-in \"hover\" method except that\r\n * instead of firing the handlerIn function immediately, hoverIntent checks\r\n * to see if the user's mouse has slowed down (beneath the sensitivity\r\n * threshold) before firing the event. The handlerOut function is only\r\n * called after a matching handlerIn.\r\n *\r\n * // basic usage ... just like .hover()\r\n * .hoverIntent( handlerIn, handlerOut )\r\n * .hoverIntent( handlerInOut )\r\n *\r\n * // basic usage ... with event delegation!\r\n * .hoverIntent( handlerIn, handlerOut, selector )\r\n * .hoverIntent( handlerInOut, selector )\r\n *\r\n * // using a basic configuration object\r\n * .hoverIntent( config )\r\n *\r\n * @param  handlerIn   function OR configuration object\r\n * @param  handlerOut  function OR selector for delegation OR undefined\r\n * @param  selector    selector OR undefined\r\n * @author Brian Cherne <brian(at)cherne(dot)net>\r\n */\r\n\r\n;(function(factory) {\r\n    'use strict';\r\n    if (typeof define === 'function' && define.amd) {\r\n        define(['jquery'], factory);\r\n    } else if (jQuery && !jQuery.fn.hoverIntent) {\r\n        factory(jQuery);\r\n    }\r\n})(function($) {\r\n    'use strict';\r\n\r\n    // default configuration values\r\n    var _cfg = {\r\n        interval: 100,\r\n        sensitivity: 6,\r\n        timeout: 0\r\n    };\r\n\r\n    // counter used to generate an ID for each instance\r\n    var INSTANCE_COUNT = 0;\r\n\r\n    // current X and Y position of mouse, updated during mousemove tracking (shared across instances)\r\n    var cX, cY;\r\n\r\n    // saves the current pointer position coordinates based on the given mousemove event\r\n    var track = function(ev) {\r\n        cX = ev.pageX;\r\n        cY = ev.pageY;\r\n    };\r\n\r\n    // compares current and previous mouse positions\r\n    var compare = function(ev,$el,s,cfg) {\r\n        // compare mouse positions to see if pointer has slowed enough to trigger `over` function\r\n        if ( Math.sqrt( (s.pX-cX)*(s.pX-cX) + (s.pY-cY)*(s.pY-cY) ) < cfg.sensitivity ) {\r\n            $el.off(s.event,track);\r\n            delete s.timeoutId;\r\n            // set hoverIntent state as active for this element (permits `out` handler to trigger)\r\n            s.isActive = true;\r\n            // overwrite old mouseenter event coordinates with most recent pointer position\r\n            ev.pageX = cX; ev.pageY = cY;\r\n            // clear coordinate data from state object\r\n            delete s.pX; delete s.pY;\r\n            return cfg.over.apply($el[0],[ev]);\r\n        } else {\r\n            // set previous coordinates for next comparison\r\n            s.pX = cX; s.pY = cY;\r\n            // use self-calling timeout, guarantees intervals are spaced out properly (avoids JavaScript timer bugs)\r\n            s.timeoutId = setTimeout( function(){compare(ev, $el, s, cfg);} , cfg.interval );\r\n        }\r\n    };\r\n\r\n    // triggers given `out` function at configured `timeout` after a mouseleave and clears state\r\n    var delay = function(ev,$el,s,out) {\r\n        delete $el.data('hoverIntent')[s.id];\r\n        return out.apply($el[0],[ev]);\r\n    };\r\n\r\n    $.fn.hoverIntent = function(handlerIn,handlerOut,selector) {\r\n        // instance ID, used as a key to store and retrieve state information on an element\r\n        var instanceId = INSTANCE_COUNT++;\r\n\r\n        // extend the default configuration and parse parameters\r\n        var cfg = $.extend({}, _cfg);\r\n        if ( $.isPlainObject(handlerIn) ) {\r\n            cfg = $.extend(cfg, handlerIn);\r\n            if ( !$.isFunction(cfg.out) ) {\r\n                cfg.out = cfg.over;\r\n            }\r\n        } else if ( $.isFunction(handlerOut) ) {\r\n            cfg = $.extend(cfg, { over: handlerIn, out: handlerOut, selector: selector } );\r\n        } else {\r\n            cfg = $.extend(cfg, { over: handlerIn, out: handlerIn, selector: handlerOut } );\r\n        }\r\n\r\n        // A private function for handling mouse 'hovering'\r\n        var handleHover = function(e) {\r\n            // cloned event to pass to handlers (copy required for event object to be passed in IE)\r\n            var ev = $.extend({},e);\r\n\r\n            // the current target of the mouse event, wrapped in a jQuery object\r\n            var $el = $(this);\r\n\r\n            // read hoverIntent data from element (or initialize if not present)\r\n            var hoverIntentData = $el.data('hoverIntent');\r\n            if (!hoverIntentData) { $el.data('hoverIntent', (hoverIntentData = {})); }\r\n\r\n            // read per-instance state from element (or initialize if not present)\r\n            var state = hoverIntentData[instanceId];\r\n            if (!state) { hoverIntentData[instanceId] = state = { id: instanceId }; }\r\n\r\n            // state properties:\r\n            // id = instance ID, used to clean up data\r\n            // timeoutId = timeout ID, reused for tracking mouse position and delaying \"out\" handler\r\n            // isActive = plugin state, true after `over` is called just until `out` is called\r\n            // pX, pY = previously-measured pointer coordinates, updated at each polling interval\r\n            // event = string representing the namespaced event used for mouse tracking\r\n\r\n            // clear any existing timeout\r\n            if (state.timeoutId) { state.timeoutId = clearTimeout(state.timeoutId); }\r\n\r\n            // namespaced event used to register and unregister mousemove tracking\r\n            var mousemove = state.event = 'mousemove.hoverIntent.hoverIntent'+instanceId;\r\n\r\n            // handle the event, based on its type\r\n            if (e.type === 'mouseenter') {\r\n                // do nothing if already active\r\n                if (state.isActive) { return; }\r\n                // set \"previous\" X and Y position based on initial entry point\r\n                state.pX = ev.pageX; state.pY = ev.pageY;\r\n                // update \"current\" X and Y position based on mousemove\r\n                $el.off(mousemove,track).on(mousemove,track);\r\n                // start polling interval (self-calling timeout) to compare mouse coordinates over time\r\n                state.timeoutId = setTimeout( function(){compare(ev,$el,state,cfg);} , cfg.interval );\r\n            } else { // \"mouseleave\"\r\n                // do nothing if not already active\r\n                if (!state.isActive) { return; }\r\n                // unbind expensive mousemove event\r\n                $el.off(mousemove,track);\r\n                // if hoverIntent state is true, then call the mouseOut function after the specified delay\r\n                state.timeoutId = setTimeout( function(){delay(ev,$el,state,cfg.out);} , cfg.timeout );\r\n            }\r\n        };\r\n\r\n        // listen for mouseenter and mouseleave\r\n        return this.on({'mouseenter.hoverIntent':handleHover,'mouseleave.hoverIntent':handleHover}, cfg.selector);\r\n    };\r\n});\r\n"]},"metadata":{},"sourceType":"module"}